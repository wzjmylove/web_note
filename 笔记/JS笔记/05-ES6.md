# ES6

## 变量声明

### let

特点

> 1、**不存在变量提升**
>
> 2、不能重复声明（不能再同一个作用域里面定义，见例4）（同名就会报错，不管是var声明还是let声明）
>
> 3、let声明的变量仅在块级作用域内有效（ {}内为一个块级作用域 ），外部无法访问内部变量
>
> 4、let进行循环i操作，都是新的变量，而非同一个i

例1：

```js
let a = 12;
function fn(){
    console.log(a);			//结果：erro	因为重复定义了a
    let a = 6;
}
```

例2：

```js
let a = 12;
function fn(){
    console.log(a);			//结果：12		因为let声明只后会立即执行赋值操作，且作用域查找会找到全局作用域
}
```

例3：

```js
function fn(){
    console.log(a);			//结果：erro	因为let没有变量声明的提升
    let a = 6;
}
```

例4：暂时性死区（本质：只要进入当前作用域，需要被使用的变量已经存在，但不可以获取，只要等到let声明代码出现后才能使用）

```js
var a = 12;
if(true){
    console.log(a);			//结果：erro	因为所声明的变量已存在
    let a = 6；
}	//这个if就是一个块级作用域

function (num){
    let num;				//erro	因为num已经存在
}

function (num){
    {
        let num;			//不报错，因为不是同一个作用域
    }
}
```

### const

声明的是常量

应用场景：确定不会再次赋值变量时使用const

特点：

> 1、不允许重复声明
>
> 2、不存在变量提升
>
> 3、块级作用域
>
> 4、值不允许被修改
>
> 5、声明必须赋初始值，否则就会报错

注：如果const是一个数组或对象，那么修改数组或对象内的属性、方法，不会报错
原因：const保存的是地址，而数据是放在堆中的，修改数据不会修改地址（**不要赋值操作，不然会改地址**）

例：

```js
const arr1 = [1, 2, 3];
arr1.push(4);				//结果：[1,2,3,4]

const arr2 = [0];
arr2 = [1];					//结果：erro	直接赋值会改变指针地址
```

#### Object.freeze()

冻结方法：将对象进行冻结，冻结后不能再修改、添加等操作，且其原型也不能被修改

语法：Object.freeze( obj )

参数：obj：需要给冻结的对象

该方法可以实现狭义的const定义（即不可修改性）

------

## 块级作用域

在es5只有全局作用域和函数（局部）作用域

因此会经常发生内层变量覆盖外层变量的情况

如：

```js
var a = '123';
function(){
	console.log(a);				//结果：undefined
	if (false)
		var a = '456';
}
```

es6中用let、const声明的变量多了个块级作用域

如：

```js
let a = 123;

function fn() {
    console.log(a);			//结果：123
    if (false) {
        let a = 465;
    }
}
fn();
```

### 闭包的变化

闭包见JS基础中的闭包板块

```js
var arr = [];
for (var i = 0; i < 5; i++) {
    arr[i] = function() {
        console.log(i);
    }
}

for (var j = 0; j < 5; j++) {
    arr[j]();					//结果：打印5个5
}
原因：变量i控制循环，循环结束后，i并未消失，泄露成了全局变量
之前解决办法：利用闭包：自执行函数（执行完后就销毁i）
```

将上述for循环内的var声明改为let声明，就可以触发闭包的作用

------

## 解构赋值

### 数组的解构赋值

定义：按照一定的模式，从数组中提取值，然后再对变量进行赋值

语法：`let [a,b,c] = ['草莓','苹果','尖尖']`
此时的 a 就是 ‘ 草莓 ’   ， b 就是 ' 苹果 '   ， c 就是 '尖尖'	a b c就是变量名

因此交换变量值，可以用：`[a,b] = [b,a]`，省去了中间变量的操作

注：数组的解构赋值对于var声明的变量也通用

#### 嵌套数组解构

不完全解构：等号左边只匹配一部分等号右边的数组

即等号左边小于等号右边

> 如：
>
> ```js
> let [,,[first,second]] = ['NO1','NO2',['NO3','NO4'],'NO5']
> //此时 first 是 NO3	，second 是 NO4
> ```

指定默认值（即：当等号左边变量大于等号右边时）

> 如：
>
> ```js
> let [red,pink = '粉色'] = ['红色']
> //此时 pink 是粉色 ， 如果不给pink赋值，那么会显示undefined
> ```
>
> 注：指定默认值必须是当前位置的项不存在或者是undefined，那么默认值才生效

默认值可以赋变量

> 如：
>
> ```js
> let [red,pink = red] = ['红色']
> ```
>
> 此时 red 是红色 ， pink 是红色
>
> ```js
> let [pink = red,red = '红色'] = []
> ```
>
> 此时会报错，因为red还未声明

### 对象的解构赋值

对象是无序的（相对于数组来说）

> 解构赋值时，变量名必须与属性名同名
>
> 如：
>
> ```js
> let Person = {
>     name: 'wz',
>     age: 18,
>     sex: 'male'
> }
> let { age, sex, name } = Person;	//结果：age 为 18 ， sex 为 'male' ， name 为 'wz'
> let { uage, usex, uname } = Person;	//结果：undefined
> ```

指定默认值（即：当等号左边变量大于等号右边时）

> 如：
>
> ```js
> let { a = 'aaa', b = 'bbb', c = a } = { a: 1, b: 2, c: 'max' }
> //结果：a 是 1 ，b 是 2 ，c 是 max
> let { A = 'aaa', B = 'bbb', C = a } = { A, B: 2, C: 'max' }
> //结果：erro，A错误	因为A再没有定义之前就使用了，因为没有给值（给''也是给值）
> let { x = 'aaa', y = 'bbb', z = a } = { x:null, y: 2, z: 'max' }
> //结果： x 是 null ，y 是 2 ， z 是 max
> let { i = 'aaa', j = 'bbb', k = a } = { i:undefined, j: 2, k: 'max' }
> //结果： i 是 aaa ，j 是 2 ， k 是 max
> ```
>
> 注：只有undefined的时候默认值才生效

解构变量名（取别名）

> 先找同名属性，再赋给对应得变量名
>
> 如：
>
> ```js
> let Person = {
>     name: 'wz',
>     age: 18,
>     sex: 'male'
> }
> let { age: uage, sex: usex, name: uname } = Person;
> //结果：uage 为 18 ， usex 为 'male' ， uname 为 'wz'
> //此时：name、age、name 为 not defined	(即报错)
> ```
>
> 即：age、sex、name、只是匹配模式，真正得变量是后面得uname等

#### 嵌套对象解构

用花括号包含

如：

```js
let Person = {
    name: 'wz',
    age: 18,
    sex: 'male',
    obj: {
        surname: 'w',
        EnglishName: 'max'
    }
}
let { obj } = Person;
//结果：{ surname: 'w', EnglishName: 'max' }
//给obj起别名就在此处取，不能在下面的代码处用引号取（即let { obj:abc } = Person;	这样会报错）

let { obj: { surname: my_surname } } = Person;
//结果：my_surname 为 w
```

### 函数得解构赋值

解构赋值用在函数得参数上，会增加一些麻烦

> 如：
>
> ```js
> let Person = {
>     name: 'wz',
>     age: 18,
>     sex: 'male',
>     obj: {
>         surname: 'w',
>         EnglishName: 'max'
>     }
> }
> 
> function fn({ name, age } = obj) {
>    	console.log(name, age);
> }
> fn(Person);					//结果：wz 18
> //如果找不到name和age属性，则返回undefined
> 
> let arr = [1, [2, 3], [4, 5, 6]];
> 
> function Fn([name, age] = obj) {
>     console.log(name, age);	
> }
> Fn(arr);					//结果：1 [ 2, 3 ]
> ```
>
> 

默认值设置

> 如：
>
> ```js
> function fn({ name = 'wz', age = 18 } = obj) {
>     console.log(name, age);
> }
> ```

------

## 箭头函数

用处：一般用在定时器上

es6新增函数

写法一

> 语法：`() => {}`		
>
> =>这个中间不能有空格	
>
> 箭头指向一个代码块
>
> {}是函数体

写法二

> 语法：`const fn = () => {}`
>
> 把一个函数赋值给fn
>
> 相当于：`const fn = function() {}`

写法三：当箭头函数内只有return语句时

> 语法：
>
> ```js
> let sum = (a,b) => a + b;	
> sum(10,20);
> //结果是30
> ```
>
> 相当于：
>
> ```js
> function sum (a,b){
> 	return a + b;
> }
> sum(10,20);
> ```
>
> 如果形参只有一个，可以省略小括号 `let sum = c => c * 100;`
>
> 注：不能返回一个实际对象	let obj = id => { id : id , name : ' wz ' }	这样写会报错
> 因为将{}解析为代码块了，而非对象的括号
> 解决办法：let obj = id => ({ id : id , name : ' wz ' })	大括号外面加小括号

### 箭头函数this指向

箭头函数没有自己的this，但是它可以继承上一层的构造函数

#### this

es5中，顶层对象是window

es6中，顶层对象是global

普通函数内的this指向window

对象内的this指向的是该对象的实例（并非对象本身，而是其实例）

> 如：
>
> ```js
> let Person = function(name, age) {
> 	this.name = name;
> 	this.age = age;
> 	this.sing = function() {
>   		console.log(this.name + '会唱歌');
>   		console.log(this);
> 	}
> }
> let wz = new Person('wz', 18);
> console.log(wz);
> wz.sing();
> //结果：wz会唱歌
> ```
>
> 此处的this指向 wz 这个实例对象，而非Person
>
> 例1：
>
> ```js
> var name = 'max';
> var age = 18;
> var obj = {
>  	name: 'wz',
>  	Myage: this.age,
>  	sing: function() {
>    		console.log(this.name + ' 的年龄是 ' + this.age);
>  	}
> }
> console.log(obj.Myage);		//结果：18
> obj.sing();				   //结果：wz 的年龄是 undefined
> ```
>
> 第一个this指向的是window，二三两个this指向obj
>
> 例2：
>
> ```js
> var name = 'max';
> var age = 18;
> var obj = {
> 	name: 'wz',
> 	Myage: this.age,
> 	sing: () => {
> 		console.log(this.name + ' 的年龄是 ' + this.age);
> 	}
> }
> console.log(obj.Myage);		//结果：18
> obj.sing();				   //结果：max 的年龄是 18		（因为所有this指向的都是window）
> ```
>

DOM对象中，this指向该DOM对象（DOM对象为一个标签，又称事件源）

#### 箭头函数的this

在对象中，this是指向实例对象的，但是如果该对象有箭头函数，那么箭头函数内的this是指向window的

原理：箭头函数的this是指向被声明的作用域里面，但是对象没有作用域，所有指向全局window作用域

如：

```js
let wz = {
    name:'wz',
    sing:() => {
        console.log(this)
    }
}
//结果：this指向window，调用不了this.name
```

推广：定义（包含）箭头函数的作用域里面this指向谁，那么箭头函数内的this就指向谁

如：

```js
let Person = function(name, age) {
    this.name = name;
    this.age = age;
    this.sing = () => {
        console.log(this.name + '会唱歌');
        console.log('this:', this);
    }
}
Person.prototype.hobby = () => {
	console.log('原型上的this.name：' + this.name);
	console.log('原型上的this：');
	console.log(this);
}
 
let wz = new Person('wz', 18);
console.log(wz);
wz.sing();
//结果：wz会唱歌
//原因：this指向wz实例对象（因为wz是由构造对象来的，在该构造对象里this就是指向实例对象，因此在箭头函数中，也是this指向实例对象）

wz.hobby();
//结果：name = ''		此时this指向的是window
```

### 箭头函数的剩余参数

#### arguments

就是传参的一个伪数组，其原型是一个Object

> 使用：放在函数里面，里面存储了所有传递过来的实参
>
> arguments是一个伪数组
>
> > 1、具有数组length的属性
> >
> > 2、按照索引的方式存储  如arguments=[2]  ；因此也可以按照数组的方式遍历
> >
> > 3、没有真正数组的一些方法 如pop()  push()
>
> 只有函数才有argumens对象，且每个函数都内置好了这个argumens

如：

```js
function fn(a, b) {
    console.log(arguments);
}
fn('a', 'b', 'c', 'd')
//结果：['a', 'b', 'c', 'd']
```

#### 运用reset参数

见扩展运算符

### 箭头函数和普通函数的区别

1、箭头函数是es6新增的

2、箭头函数没有this

3、箭头函数没有arguments，但是可以用rest参数代替

4、箭头函数**不能使用new定义**，否则会报错（即不能在构造函数中使用）

5、没有call apply bind 修改this值

------

## 拓展运算符

在箭头函数中，没有arguments，但是可以用拓展运算符（es6新增）

拓展运算符：

> 语法：  `...变量名`		（放在形参中）
>
> 又名：rest参数
>
> 该返回的是一个真正的数组，而非arguments伪数组
>
> 作用：
>
> > 1、用于获取函数的多余的参数，避免了使用arguments对象
> >
> > 2、扩展作用

### 函数剩余参数

> 如：
>
> ```js
> function fn(...args) {
>  	console.log(args);
> }
> fn('a', 'b', 'c', 'd', 123);
> //结果：['a', 'b', 'c', 'd', 123]
> ```
>
> ```js
> function fn(a, b, ...args) {
>  	console.log(a, b);				//结果：'a'  'b'
>  	console.log(args);				//结果：['c', 'd', 123]
> }
> fn('a', 'b', 'c', 'd', 123);
> ```
>
> 注：rest参数必须放在形参最后
>
> ```js
> function fn(...args, a, b) {
>  console.log(a, b);				
> }
> fn('a', 'b', 'c', 'd', 123);		//结果：报错，rest参数必须放在形参最后
> ```
>
> > 普通函数和箭头函数都可以用rest参数
> >
> > ```js
> > fn = (...args) => {
> >         console.log(args);
> > }
> > fn('a', 'b', 'c', 'd', 123)
> > //结果：['a', 'b', 'c', 'd', 123]
> > ```
> >
> > 

### 扩展作用

将数组转为逗号分隔开参数序列（相当于将数组的元素遍历出来）

如：

```js
let arr = ['苹果', '香蕉', '橘子'];
console.log(...arr);
//结果：苹果 香蕉 橘子
```

该扩展运算符也能搭配解构数组使用

如：

```js
let arr = ['苹果', '香蕉', '橘子'];
let [fruit, ...more] = arr;
console.log(fruit);			//结果：苹果
console.log(more);			//结果：[ '香蕉', '橘子' ]
```

### 扩展运算符的应用

> 1、合并数组
>
> 2、将伪数组转换为数组
>
> 3、将字符串转为数组

#### 合并数组

es5中用concat方法

es6用扩展运算符

> 1、使用push加rest参数
>
> ```js
> let arr1 = [1, 2];
> let arr2 = [3, [4, 5]];
> arr1.push(...arr2);
> //结果：arr1：[1, 2, 3, [4, 5]]
> ```
>
> 2、多个rest参数
>
> ```js
> let arr1 = [1, 2];
> let arr2 = [3, [4, 5]];
> let arr3 = [...arr1, ...arr2];
> //结果：arr3：[1, 2, 3, [4, 5]]
> ```

#### 伪数组（类数组）转换为数组

比如在dom绑定中，querySelectorAll就是获取的一个伪数组

```js
let btn = document.querySelectorAll('button');
let newbtn = [...btn];
console.log(newbtn);
//结果：一个数组，数组元素是button标签
```

#### 字符串转为数组

相当于str.split('')

```js
let str = '王泽的英文名是max。'
let newstr = [...str];
console.log(newstr);
//结果：['王', '泽', '的', '英', '文', '名', '是', 'm', 'a', 'x', '。']
```

------

## ES6新增方法

### for of 循环

该循环是es6新增循环，作为遍历所有数据结构的统一方法

一个数据结构只要有Symbol.itrerator属性，就被视为iterator接口（迭代器），就可以使用for of 遍历其成员

> 三类结构原生就有iterator接口：**数组、类数组对象、Map和Set结构**
> 对象没有iterator接口
>
> 作用：
>
> > 1、为各种数据结构提供一个统一的简便的访问接口
> >
> > 2、是数据结构的成员能够按照某种次序排序
>
> 因此，有了iterator接口就可以供for of遍历（即for of作用为2点，iterator接口作用为3点）

#### 循环值 value

```js
let arr = ['苹果', '香蕉', '葡萄', '草莓'];
for (let val of arr)
    console.log(val);
//结果：'苹果', '香蕉', '葡萄', '草莓'
```

#### 循环索引 index

在for in中，是`for(let key in obj)`，此时key就是索引

for of中，需要借助数组的方法keys()	

见 JS高级 笔记中 -> ES5新增方法 -> 数组 -> keys()

```js
let arr = ['苹果', '香蕉', '葡萄', '草莓'];
for (let index of arr.keys())
	console.log(index);
//结果：0, 1, 2, 3
```

### 数组新增方法

#### Array.from()

> 语法：`Array.from(arr , p2 , p3 )`
>
> 参数：arr：需要被转化成数组的伪数组对象
>
> ​		   p2：类似数组的map方法，对每个元素进行处理，并将处理好的值放到 retrun中
> ​				  p2是一个function，形参只有两个currentValue和index，并没有map()的第三个形参arr
>
> ​		   p3：用于绑定this，默认值是指向window
>
> 作用：将arr伪数组转化为数组（与reset参数的作用一样）

如：

```html
<body>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <script>
        let div = document.querySelectorAll('div');
        console.log(Array.from(div));
        //结果：[div, div, div, div]
        let arr = Array.from(div, (val, index) => {
            console.log('val', val);		//结果：四个dom对象
            console.log('index', index);	//结果：0，1，2，3
            return val
        }, [])
        console.log(arr);
        //结果：[div, div, div, div]
    </script>
</body>
```

#### Array.of()

作用：将一组值转化为数组，且弥补数组构造函数（new Array）的不足

> 数组构造函数的不足：
>
> Array()：[ ]
>
> **Array(3)：[ empty * 3 ]**
>
> Array(3,4,5)：[ 3 , 4 , 5 ]

使用Array.of()后

> Array.of()：[ ]
>
> **Array.of(3)：[ 3 ]		长度为1**
>
> Array.of(3,4,5)：[ 3 , 4 , 5 ]

#### findIndex()

find和indexOf的结合，找的是位置，找到则返回索引值（下标index），**找到一个后就返回**；没有找到则返回-1

语法：arr.findIndex ( function ( item , index , arr )  {} )

#### fill()

> 语法：arr.fill( val , start , end )	
>
> 参数：val：需要填充的内容
>
> ​	       start：填充开始的位置	可选
>
> ​		   end：填充结束的位置	可选
> ​				    不给start，默认全部填充，不给end，默认从start开始之后的全部填充
>
> ​		   左闭右开

如：

```js
let fruit = new Array(3); //[empty*3]
fruit.fill('苹果');
console.log(fruit);			//结果：[ '苹果', '苹果', '苹果' ]
fruit.fill('草莓', 1, 2);
console.log(fruit);			//结果：[ '苹果', '草莓', '苹果' ]
```

### 对象新增方法

#### Object.is()

> es5中比较两个值相等方法：
>
> === 严格等于运算符	
>
> == 相等运算符
>
> 缺陷：== 会隐式转换数据类型
>
> ​	   	=== NaN 不等于自身，+0 等于 -0

作用：比较两个值是否相等（如果人的肉眼是认为相等的，那么该方法返回就是true）

返回值：Boolean

如：

```js
Object.is(NaN,NaN);		//结果：true
Object.is(+0,-0);		//结果：false
+0 == -0;			   //结果：true
+0 === -0;			   //结果：true
Object.is({},{});		//结果：false	因为是引用类型
```

#### Object.assign()

> 作用：
>
> > 1、合并对象		
> >
> > 2、浅拷贝
> > 注：目标对象是一个新的地址的话，是深拷贝
>
> 语法：`Object.assign(target,source,....)`
>
> 参数：target：复制的目标对象
>
> ​		  source：源对象，复制可枚举的对象		可以有多个源对象
>
> 解释：将source复制到target，进而形成一个新对象

如：

浅拷贝

```js
let target = { apple: '苹果' },
    source1 = { banana: '香蕉' },
    source2 = { orage: '橘子' };
let fruit = Object.assign(target, source1, source2);
console.log(fruit, target);
//结果都是：{ apple: '苹果', banana: '香蕉', orage: '橘子' }

fruit.apple = '苹果派';
console.log(target);
//结果：{ apple: '苹果派', banana: '香蕉', orage: '橘子' }
```

深拷贝

```js
let target = { apple: '苹果' },
    source1 = { banana: '香蕉' },
    source2 = { orage: '橘子' };
let newfruit = Object.assign({}, target, source1, source2);
console.log(newfruit);		//结果：{ apple: '苹果', banana: '香蕉', orage: '橘子' }
console.log(target);		//结果：{ apple: '苹果' }
```

注：如果target和source中有两个或多个同名的属性，会覆盖

## symbol

表示独一无二的值

> 作用：确保对象使用唯一标识符（作属性名），保证属性名不冲突
>
> 语法：let xxx = Symbol(str)
>
> 参数：str：用于描述参数的一个字符串，没有任何意义；也可以传其他的，会调用toString方法，再生成symbol值
> 					在控制台输出的时候区分是哪个值
>
> typeof Symbol()：即symbol的类型相当于是字符串（**特殊的字符串**），**但symbol实际仍是一个基本数据类型**
>
> 注：symbol的值不能参与运算，也不能转化为数字型

> 每个Symbol是独一无二的
>
> 如：
>
> ```js
> let s1 = Symbol();
> let s2 = Symbol();
> s1 == s2;				//false
> s1 === s2;				//false
> 
> //传字符串
> let s3 = Symbol('name');
> let s4 = Symbol('age');
> console.log(s3);		//Symbol(name)
> console.log(s4);		//Symbol(age)
> 
> //传对象
> let s5 = Symbol({name:'wz'})
> console.log(s5);		//Symbol([object,Object])
> ```
>
> 

### 应用

对象的属性名若重复，则会出现覆盖现象，使用symbol可以解决这个问题

如：

```js
const obj = {
    name: '餐馆',
    [Symbol('category')]: "中餐",
    [Symbol('category')]: "西餐"
}
// 使用 symbol 解决 属性名相同进行覆盖的问题
```

#### 特殊方式获取symbol

使用 for in 无法获取symbol的属性名，即无法遍历symbol的成员

| 方法                           | 描述                                                       |
| ------------------------------ | ---------------------------------------------------------- |
| Object.getOwnPropertySymbols() | 返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 |
| Reflect.ownKeys()              | 返回所有类型的键名                                         |

##### Object.getOwnPropertySymbols() 

该方法只能获取symbol属性名，没法获取其他正常的属性名，也没法获取属性值

语法：Object.getOwnPropertySymbols(obj) 

如：

```js
const obj = {
    name: '餐馆',
    [Symbol('category')]: "中餐",
    [Symbol('category')]: "西餐"
}
console.log(Object.getOwnPropertySymbols(obj));
//结果：[Symbol(category), Symbol(category)]
```

#####   Reflect.ownKeys()  

返回所有的属性名

语法：  Reflect.ownKeys(obj)  

##### 访问属性值

------

## Map数据结构

对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键(ES6加入了Symbol作为属性名称)。这给它的使用带来了很大的限制。

为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
即：Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现

语法：`let m = new Map()`

| 方法               | 描述                                 |
| ------------------ | ------------------------------------ |
| map.set(key,value) | 设置键值对，返回Map结构              |
| get(key)           | 读取key对应的值，找不到就是undefined |
| map.delete(key)    | 删除某个键，返回true，失败返回false  |
| map.has(key)       | 返回布尔值，表示key是否在Map中       |
| map.clear()        | 清除所有成员，没有返回值             |
| map.size属性       | 返回成员总数                         |

### 设置键值对 set()

> 语法：`m.set(key,val)`
>
> 参数：key：属性名（可以是字符串str，可以是函数fn，可以是对象obj）
>
> ​			val：属性值
>
> map也能接受数组作为传参：`let m = new Map( [ [key1,val1] , [key2,val2] ] )`	
> 不能接受对象作为传参
>
> set()不能接受Map的方法，因为他会将该数组作为一个key去处理

如：

```js
let m = new Map();
let fn = () => {
    console.log('我是一个函数');
};
m.set(fn, '我向map传了一个函数');
```

结果：

![js_ES6_Map_set](F:\学习\前端培训\笔记\image\js_ES6_Map_set.png)

### 获取 get()

> 语法：`m.get(key)`
>
> 作用：返回对应key的value
>
> 对于key是字符串的，直接传key	如：`m.get('name')`
>
> 对于key是引用类型的	如：`m.get(fn)`
> 不能直接在括号内给引用类型	如：`m.get({name:'wz})  //原意是想找key为obj类型的{name:'wz}的value，但是会返回undefined`
> 即，引用类型必须是具名的，不能是匿名的，否则get不到

### 查询 has()

> 语法：`m.has(key)`
>
> 作用：判断m里面有无这个key，返回一个Boolean

### 删除 

#### delete()

> 语法：`m.delete(key)`
>
> 作用：删除key，同时删除该key对应的value，成功返回true，失败删除false

#### clear()

> 语法：`m.clear()`
>
> 作用：删除m里面的所有成员

### 遍历

1、通过for of和entries遍历

> 语法：`for(let item of m)`
>
> ​		或`for(let item of m.entries)`
>
> 遍历结果：每个item都代表一个Map成员（数组形式的键值对）

2、通过扩展运算符遍历，直接 [...m]

3、m.forEach( ( val,key ) => {} )

### Map和Object的区别

> 1、删除：涉及到大量删除操作，选择Map（Map的delete操作比它本身set插入和查找都快）
>
> 2、查找：选择Object，查找较快
>
> 3、插入：涉及到大量插入操作，选择Map
>
> 4、内存：如果给两者一个固定的内存，Map比Object多存50%

------

## Set数据结构

它类似于数组，但是成员的值都是唯一的，没有重复的值

它可以包含任意数据类型

> 语法：`let s = new Set()`
>
> 作用：
>
> > 1、数组去重									  语法：`[...new Set(arr)]`
> >
> > 2、数组去重并化为字符串				语法：`[...new Set(str)].join('')`

Set方法

| 方法              | 描述                                         |
| ----------------- | -------------------------------------------- |
| set.add(value)    | 添加某个值，返回 Set 结构本身                |
| set.delete(value) | 删除某个值，返回一个布尔值，表示删除是否成功 |
| set.has(value)    | 返回一个布尔值，表示该值是否为 Set 的成员    |
| set.clear()       | 清除所有成员，没有返回值                     |

### add()

add可以链式操作

> 语法：`s.add(1).add(2)`
>
> 原因：add返回自己

### size

这是一个属性，表示Set的成员个数，相当于arr.length

### 遍历

1、用for of遍历		语法：`for(let item of s)`

2、用forEach遍历	

> 语法：`s.forEach(function(val,index) {})`
>
> 结果：val和index都是set的值
> 因为 set 不是键值对形式，所以 **val 和 index 是一致的**

------

## Class

本质上还是一个函数，不过一般称为 ‘ 类 ’

可以将class看作一个语法糖（语法糖：简写模式，原生代码的简写）

> 作用：让对象原型的写法更加清晰，更像面向对象的编程的语法
>
> 语法：
>
> ```js
> class Person {
>     //类共有的属性放到constructor里面
>     constructor(name, age) {
>         this.name = name;
>         this.age = age
>     }
>     //方法放外面，方法会在原型上，且多个方法不需要逗号隔开
>     hobby() {
>         console.log(this.name + '爱唱歌');
>     }
>     //属性写外面，属性不会在原型上
> }
> 
> //该方法的写法相当于构造函数的
> Person.prototype.hobby = function () {
>         console.log(this.name + '爱唱歌');
> }
> ```
>
> 应用：
>
> ```js
> //实例化对象
> let p1 = new Person('wz', 18);
> console.log(p1);			//结果：Person {name: 'wz', age: 18}
> p1.hobby();					//结果：wz爱唱歌
> ```
>

### class的继承

使用关键字即可继承：extends

> 语法：`class Son extends Father {}`
>
> 特点：
>
> > 1、不需要像原型链继承一样将子类的constructor指向自己（即：Son.prototype.constructor = Son）
> >
> > 2、子类会直接继承父类的属性和方法，不需要写其他任何代码

#### 缺点

**不能直接在`class Son extends Father {}`的大括号内添加属性，会报错**，因为如果不调用`super()`方法，子类就得不到自己的`this`对象

#### 解决

super关键字

super关键字必须写在子类的constructor中

> 语法：
>
> ```js
> class Son extends Person {
> 	constructor(name, age, sex) {
>         //必须先super继承
> 		super(name, age)
> 		this.sex = sex;
> 	}
> }
> ```
>
> 作用：调用父类的constructor( x , y , ...)
>

------

## AJAX

ajax就是异步的 JS 和 XML

别称：XMLHttpRequest

作用：通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势: 无刷新获取数据

H5采用json数据格式通信，但是H4.1之前采用XML数据格式通信

AJAX优点：

> 1、可以无需刷新页面而与服务器端进行通信，因此可以更快回应用户的操作
>
> 2、允许你根据用户事件来更新部分页面内容

缺点：

> 1、没有浏览历史，不能回退
>
> 2、存在跨域问题(同源)
>
> 3、SEO不友好，(SEO意思: 是搜索引擎优化)

AJAX使用场景：

> 1、评论加载
>
> 2、表单注册/登录

### AJAX的使用

> 1、创建ajax对象
>
> 2、设置请求方式和请求地址
>
> 3、发送请求
>
> 4、获取服务器端响应数据

#### 创建ajax对象

语法：`let xhr = new XMLHttpRequest()`

#### 设置请求方式和请求地址

一般调用ajax对象中的open方法

open()：

> 语法：`xhr.open(method,url)`
>
> 参数：method：请求方法，一般常用的是get、post（方法可以大写，也可以小写，单数需要注意其是**字符串，要打引号**）
>
> ![AJAX_method](F:\学习\前端培训\笔记\image\AJAX_method.png)
>
> ​		url：链接，也是字符串类型，要打引号

#### 发送请求

一般调用ajax对象中的send方法

send()：

> 语法：`xhr.send(data)`
>
> 参数：如果是get方法，那么data可以是null，也可以不写
>
> ​			如果是post方法，那么需要向服务器发送数据，此时data的值就是需要发送的数据

#### 获取服务器端响应数据

**因为send方法是异步，所以只能通过用事件方式来侦听获取**

常用事件侦听方式：

> 1、onload：只调用一次，无判断码，但不兼容IE低版本
>
> 2、onreadystatechange：会多次调用，有判断码，兼容IE版本

监听之后，利用XMLHttpRequest对象里面的一个属性responseText获取数据，但获取的是一个JSON格式，需要反序列化JSON.parse

------

##### onload

AJAX整个流程语法：

```js
let xhr = new XMLHttpRequest();
xhr.open('get', 'url');
//传递get请求
xhr.send();
xhr.onload = () => {
    let data = xhr.responseText;
    data = JSON.parse(data);
    console.log(data);
}
//结果：data就是url服务器回传的JSON反序列化后的数据（是一个数组形式）
```

##### onreadystatechange

判断码：`xhr.readyState`

> 返回值：0 1 2 3 4
>
> 0：当前ajax请求建立了，但是没有初始化
>
> 1：代表初始化完成，可以发起请求
>
> 2：发送请求了，后台接受完毕
>
> 3：后台处理中
>
> 4：后台处理完毕，并返回了数据

如：

```js
let xhr = new XMLHttpRequest();
xhr.open('get', 'url');
//传递get请求
xhr.send();

xhr.onreadystatechange = () => {
    //4：处理完数据并返回数据
    if (xhr.readyState == 4) {
        //表示返回数据没有问题
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            let data = JSON.parse(xhr.responseText)
            console.log('请求成功\n', data);
        }
    }
}
```

##### 响应状态码

语法：`xhr.status`

浏览器也有响应状态码

HTTP请求的结果用状态码来表示请求的结果：

![AJAX_响应状态码](F:\学习\前端培训\笔记\image\AJAX_响应状态码.png)

200<= xhr.status <300 || xhr.status == 304	表示返回数据没有问题，非这个区间，则应去看代码也没有写错

500一般是代码写错了

### AJAX的get封装

```js
function Ajax_Get(url, sucessFn) {
    //1.创建对象并初始化
    let xhr = new XMLHttpRequest();
    xhr.open('get', url);
    //2.发送请求
    xhr.send();
    //3.接受返回
    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
            if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                let data = JSON.parse(xhr.responseText);
                //执行成功后的函数
                sucessFn(data);
            }
        }
    }
}

//封装函数的使用
Ajax_Get(url, res => {	//res：成功时返回的data
    //doSomethings
})
```

注：get 方式是可以携带参数，不过该参数应携带在url上且参数为字符串，如 `xhr.open('get', 'http://localhost:3000' + '?' + 'unmae = "wz"');`
		此时后端接受到的会有一个对象：`{ unmae : 'wz'}`

### AJAX的post请求

用于表单提交

注：post携带的参数可以不再拼接在url中，而是将参数写在send里面，且参数必须是object对象类型

> 解决携带参数是字符串的方法：设置请求头 (会将字符串data自动转化为Object格式传递给服务端)
>
> 语法：`xhr.setRequestHeader('Conten-Type', 'application/x-www-form-urlencoded')`

如：

```js
function Ajax_Post(url, data, sucessFn) {
    //1.创建对象并初始化
    let xhr = new XMLHttpRequest();
    xhr.open('post', url);
    //2.设置请求头
    xhr.setRequestHeader('Conten-Type', 'application/x-www-form-urlencoded'); //该方法可以将字符串转换为一个对象
    let a = xhr.setRequestHeader('Conten-Type', 'application/x-www-form-urlencoded');
    console.log(a);
    //3.发送请求
    xhr.send(data); //data是需要上传的数据
    //4.接受返回
    xhr.onreadystatechange = () => {
        if (xhr.readyState == 4) {
            if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                let data = JSON.parse(xhr.responseText);
                //执行成功后的函数
                sucessFn(data);
            }
        }
    }
}

Ajax_Post('http:localhost:8000/', 'name:"wz"', res => {	//data形参处，字符串内不要有空格
    console.log(res);
})
```

### 请求超时和网络异常

如果网络请求时间很长或网络异常，则AJAX请求会一直持续很长时间，用户体验差

#### 请求超时

> 解决办法：在初始化后，限定请求时间
>
> 语法：
>
> ```js
> xhr.timeout = n;	//n为自己设置的请求时间，超过n则显示请求超时	单位：ms
> xhr.ontimeout = () => {
>     doSomethings;
>     //在n毫秒后doSomethings()
> }
> ```
>
> 注：在超时后，AJAX代码只执行到ontimeout完，后续的send等就不执行了

#### 网络异常

> 解决办法：  1、在初始化后，限定请求时间
>
> ​					2、网络异常回调（一般用这个，不用限定请求时间）
>
> ```js
> xhr.onerror = () => {
> 	doSomethings;
>     //网络异常，请求失败后执行doSomethings
> }
> ```
>
> 注：在超时后，AJAX代码只执行到onerror完，后续的send等就不执行了

------

## 跨域

> 接口的组成：协议（http、https、ftp）+ 域名（127.0.0.1、baidu.com）+ 端口（3000，8000）
>
> 定义：一个网页向另一个**不同域名/不同协议/不同端口**的网页请求资源，这就是跨域
>
> 原因：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。因为浏览器使用了**同源策略**
> 		   同源策略的优势：提高安全
>
> 隐患：在没有设置跨域时，如果向外源访问，则会发送数据，但是该数据会被游览器拒收，因此会报错`NO 'Access-Control-Allow-Origin`
>
> 跨域问题的解决：
>
> >  1、前端使用jsonp （不推荐使用）
> >
> >  2、后台Http请求转发
> >
> >  3、**后台配置同源Cors （推荐）**
> >
> >  4、使用SpringCloud网关
> >
> >  5、**使用nginx做转发 (推荐)**

### jsonp解决跨域

不推荐，因为

> 不契合实际开发
>
> 有顺序问题
>
> 不可控制（因为页面自动加载并访问url了，没有做到需要访问时才访问）

利用JSONP方法需要用到jquery库

语法：

```html
<script src = 'jquery.js'></script>	
<script src = 'url'>	
    //JSONP会默认返回一个user对象，该对象就是服务器返回的数据
</script>
<script>
    现在可以直接调用user了
</script>
```

此时即可跨域访问url地址了

注：script标签有src后，里面的代码就不执行了

### CORS解决跨域

CORS是设置一个一个响应头，该请求允许跨域，浏览器收到该响应以后就会对响应放行

CORS详细在MDN上查找

后端的代码：`res.header({'Access-Control-Allow-Origin':'*'})`

------

## 回调地狱

回调函数：当一个函数作为一个参数传入到另一个方法中时，且该函数不会立即执行，只有当满足条件后才会执行，才是回调函数

异步任务：异步执行，不会阻塞后面的任务执行

回调地狱：在异步执行中若想按照一定顺序执行代码，必循回调函数内部调用回调函数
缺点：不便于阅读，不便于处理异常
如：

```js
setTimeout(() => {
    console.log("8点 起床了");
    setTimeout(() => {
        console.log("9点 起床了");
        setTimeout(() => {
            console.log("9点30 去上班");
        }, 500);
    }, 1000);
}, 1500)
//此时结果才是 8 9 9.30
```

解决回调地狱的方法：Promise

## Promise

Promise 是异步编程的一种解决方案

> Promise是一个构造函数
>
> 语法：`new Promise(function(resolve,reject) {})`
>
> 参数：resolve：成功调用
>
> ​		   reject：失败调用
>
> 返回值是promise对象

Promise状态：

> 1、pending（进行中)
>
> 2、fulfilled（已成功）
>
> 3、rejected（已失败）

### Promise基本流程

![js_ES6_Promise基本流程](F:\学习\前端培训\笔记\image\js_ES6_Promise基本流程.png)

### Promise方法

#### then()

then表示是Promise的一个回调函数，在Promise成功或失败后执行

> 语法：`new Promise(function(resolve,reject) {}).then( function sucess(value){} , function fail(){} )`
>
> 参数：value：Promise成功或失败时，resolve或reject括号里面的值
>
> ​			function sucess：resolve时执行的函数（Promise成功时执行的函数）
>
> ​			function fail：reject时执行的函数（Promise失败时执行的函数）
>
> 注：一般不写fail函数，因为不方便阅读，因此fali一般在catch方法里面捕获

如：

```js
let promise = new Promise((resovle, reject) => {
    setTimeout(() => {
        let flag = false;
        console.log("8点 起床了");
        if (flag) {
            resovle("去洗漱吧")
        } else {
            reject("迟到了")
        }
    }, 1000);
}).then(
    (value) => {
        console.log(value);
    },
    (value) => {
        console.log(value);
    }
)
//结果：8点 起床了		迟到了
```

#### catch()

> 语法：`promise().catch(function fail(){})`
>
> 参数：function fail：reject时执行的函数（Promise失败时执行的函数）

如：

```js
let promise = new Promise((resovle, reject) => {
    setTimeout(() => {
        let flag = false;
        console.log("8点 起床了");
        if (flag) {
            resovle("去洗漱吧")
        } else {
            reject("迟到了")
        }
    }, 1000);
}).then(
    (value) => {
        console.log(value);
    },
).catch(err => { // 用于指定发生错误回掉的函数
	console.log(err);
})
```

#### resolve()、reject()

语法：`new Promise.resolve('xxx')`		`new Promise.reject('xxx')`

相当于：`new Promise((resovle =>{ resolve('xxx') })`

#### all()

> 作用：将多个实例包装成一个新的实例
>
> 语法：`Promise.all( [p1,p2,p3] ).then(values => {xxx})`
>
> 参数：p1、p2、p3，表示之前创建的Promise
>
> ​	   	values：一个存放着p1、p2、p3的resolve的数组
>
> 返回：一个新的Promise对象
>
> 注：如果p1、p2、p3等有一个reject，就会报错
> 因此必须保证p1、p2、p3全是resolve状态（就算加了catch，也不会执行all，而是只执行catch）

#### race()

> 作用：将多个实例包装成一个新的实例，并返回最快resolve的值（若reject先执行，一样会报错）
> 			最快resolve的执行：比如定时器，100ms比500ms快，因此返回的是100ms情况下的resolve
>
> 语法：`Promise.race( [p1,p2,p3] ).then(values => {xxx})`
>
> 返回：一个新的Promise对象，但只含有一项

------

## async & await

async & await是建立在promise上的，但是不能取代promise

### asycn 关键字

async 关键字用于声明**异步函数**，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。

使用：

> ```js
> //函数声明
> async function fn() {}
> //函数表达式
> let bar = async function(params) {}
> //箭头函数
> let baz = async() => {}
> //class类
> class Per {
>     async per() {}
> }
> ```
>

返回：一个Promise对象

> 如果是用return返回，则是用Promise的resolve
>
> 如果是用throw，则是抛出异常，相当于Promise的reject
>
> 一样能调用then()、catch()

如：

```js
let Fn = async(num) => {
    if (num > 10)
        return num + '是大于10的';
    else {
        throw num
    }
}
console.log(Fn(11));		//返回一个状态为fulfilled的Promise
console.log(Fn(5));			//返回一个状态为rejected的Promise

//console.log(Fn(11))也可以写成
Fn(11).then(value => {
	console.log(value);
}).catch(value => {
	console.log(value);
})
```

相当于：

```js
let num = 5;
let Fn = new Promise((reslove, reject) => {
    if (num > 10)
        reslove(num + '是大于10的');
    else {
        reject(num)
    }
});
console.log(Fn);
```

### await 关键字

> 定义：await 也是一个修饰符，**只能放在async定义的函数内**。可以理解为等待(异步方法执行完成)。
> 即：等待一个Promise的结果，不能单独使用
>
> 作用：使用await后代码都可以视作同步执行

如：

```js
async function Fn() {
    let p = new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, '我是一个传参')		//此时resolve为undefined
    })
    console.log(p);
}
Fn();
//结果：此时Promise会一直出于pending运行状态
```

解决：

```js
async function Fn() {
    let p = new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, '我是一个传参')		//此时 '我是一个传参' 就是resolve的值
    })
    console.log(await p);		//结果：打印了  '我是一个传参'
    console.log(p);				//此时能够成功执行p，最终打印	'我是一个传参'
}
Fn();
```

又：

```js
async function Fn() {
    console.log(1);
    console.log(3);
    let p = new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, '我是一个传参')		
    })
    //await会造成代码的堵塞
    console.log('4', await p);		
    console.log('5', p);				
    console.log(2);
}
Fn();

//结果： 1 3 4 5 2
```

await跟非promise

```js
async function Fn() {
    let p = new Promise((resolve, reject) => {
        resolve('成功调用');
        reject('失败调用');
    });
    //await 右侧是promise（成功/失败的状态）
    let a = await p;
    console.log(a);		//结果：'成功调用'
    //await 右侧是其他数据类型（非promise）
    let b = await 20;
    console.log(b);		//结果：20
}
Fn();
```

```js
async function Fn() {
    //promise只有失败reject时
    let p = new Promise((resolve, reject) => {
        reject('失败调用');
    });
    let a = await p;
    console.log(a);		//结果：报错
    let b = await 20;
    console.log(b);
}
Fn();
```

解决报错的方法：**try  catch**

利用 try  catch 包裹await，以此来捕获异常

```js
async function Fn() {
    //promise只有失败reject时
    let p = new Promise((resolve, reject) => {
        reject('失败调用');
    });
    try {
        let a = await p;
        console.log(a); 
        let b = await 20;
        console.log(b);
    } catch (err) {
        console.log(err);	//结果是捕获了异常，try里面不执行，而是执行catch
    }
}
Fn();
```

### 案例

#### 传统promise

正常使用Promise实现顺序异步操作（同步操作），需要用到`then`的链式操作

缺点：过于冗余

```js
let SayHi = (name) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(name);
        }, 500)
    })
}

SayHi('wz').then(
    (val) => {
        console.log('你好 ' + val);
        return SayHi('max')
    }
).then(
    (val) => {
        console.log('你好 ' + val);
        return SayHi('wzj')
    }
).then(
    (val) => {
        console.log('你好 ' + val);
    }
)
//通过连续 .then 方法，实现顺序打印
//结果：'你好 wz'	'你好 max'	'你好 wzj'
```

#### async + await

```js
let SayHi = (name) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(name);
        }, 500)
    })
}

async function Fn() {
    let say1 = await SayHi('wz');
    console.log(say1);
    let say2 = await SayHi('max');
    console.log(say2);
    let say3 = await SayHi('wzj');
    console.log(say3);
}
Fn();
//结果：'你好 wz'	'你好 max'	'你好 wzj'
```

## 正则表达式

不只有JS有正则表达式，python这些也有

正则表达式是一个对象

作用：是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。

> 正则表通常被用来检索、替换那些符合某个模式（规则）的文本.
>
> 1、验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。     
>
> 2、敏感词过滤: 正则表达式还常用于过滤掉页面内容中的一 些敏感词(替换)
>
> 3、匹配所需要的部分: 或从字符串中获取我们想要的特定部分(提取)等 。

### 转义符

\		意思：将原有字符进行转义

如：

```js
let str1 = "今天\"天气\"很好";
console.log(str1);
//结果：今天"天气"很好		能够将引号给展示出来
let str2 = '我\\和\\你'
console.log(str2);
//结果：我\和\你				需要两个\才能展示\
```

### RegExp正则表达式

作用：简化字符串操作而生，用于检索一个字符串中特定的字符规则

#### 创建

> 1、字面量创建		
>
> 2、构造函数创建	`new RegExp('模式', '修饰符')`

##### 字面量创建

> 语法：`/模式（怎么去进行匹配）/修饰符（g，i，m）`
>
> 注：
>
> > 1、不给修饰符的情况下，只返回匹配到的第一个
> >
> > 2、如果给了修饰符g，则返回全部		语法：`let reg = /ze/g`
> > g代表全局搜索的意思

如：

```js
let str = 'wangze';
let reg = /ze/;
console.log(str.match(reg));

let reg2 = /xy/;
console.log(str.match(reg2));
```

结果：

![JS_正则](F:\学习\前端培训\笔记\image\JS_正则.png)

##### 构造函数创建

> 语法：`new RegExp('模式', '修饰符')`

构造函数的括号内可以直接跟一个正则表达式	即：`new RegExp(/wz/)`

优点：当该正则表达式是一个变量时，用构造函数创建更方便

如：

```js
let str = 'zeze';
let reg1 = new RegExp(/ze/);
console.log(str.match(reg1));

let reg2 = new RegExp('z', 'g');
console.log(str.match(reg2));
```

结果：

![JS_正则_结果2](F:\学习\前端培训\笔记\image\JS_正则_结果2.png)

### 正则表达式的方法

#### test() 

> 作用：表示该字符串是否匹配正则的规则
>
> 返回：布尔值
>
> 语法：`reg.test(str)`

```js
let str = 'zhuzhu';
let reg = new RegExp(/u/);
console.log(reg.test(str));
//结果：true
```



#### exec()

> 作用：表示该字符串是否匹配正则的规则
>
> 返回：返回一个匹配结果的数组（只返回首次匹配到的结果），没有匹配到则是null
> 和str.match差不多
>
> 语法：`reg.exec(str)`

```js
let str = 'zhuzhu';
let reg1 = new RegExp(/u/);
console.log(reg1.exec(str));	//只返回第一个

let reg2 = new RegExp(/h/, 'g');
console.log(reg2.exec(str));	//返回第一个 h
console.log(reg2.exec(str));	//返回第二个 h
```

结果：

![JS_正则_exec_结果](F:\学习\前端培训\笔记\image\JS_正则_exec_结果.png)

#### compile()

> 作用：用于改变正则表达式的内容（即将之前reg的正则内容改为一个新的正则内容，后续的正则匹配就用新的正则内容）
>
> 语法：`reg.compile(newreg)`
>
> 参数：newreg：新的正则表达式，字符串型 或 正则

```js
let str = 'zhuzhu';
let reg1 = new RegExp(/u/);
reg1.compile(/h/);				//括号内为正则时
console.log(reg1.exec(str));

reg1.compile('z');				//括号内为字符串时
console.log(reg1.exec(str));
```

结果：

![JS_正则_compile_结果](F:\学习\前端培训\笔记\image\JS_正则_compile_结果.png)

### 修饰符

修饰符是可以挨着写，比如 gi ，表示全局匹配且不区分大小写

g

> 作用：全局匹配，匹配所有满足条件的值
>
> 返回：一个数组

i

> 作用：不区分大小写

m

> 作用：多行匹配
>
> 如：
>
> ```js
> let str = 'wz is handsome\nwz is handsome';
> let reg1 = /^WZ/gi;
> console.log(str.match(reg1));
> let reg2 = /^WZ/gim;
> console.log(str.match(reg2));
> ```
>
> 结果：
>
> ![JS_正则_修饰符](F:\学习\前端培训\笔记\image\JS_正则_修饰符.png)

### 元字符

定义：一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如/ab*c/
特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等

参考 : https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp

| **元字符** | **说明**                                                     |
| ---------- | ------------------------------------------------------------ |
| \d         | 匹配数字                                                        相当于  `[0-9]` |
| \D         | 匹配非数字                                                    相当于 `[^0-9]` |
| \w         | 匹配任意字母、数字和下划线                       相当于 `[ A-Z  a-z  0-9  _ ]` |
| \W         | 匹配非字母、数字和下划线                           相当于 `[^0-9A-z]` |
| \s         | 匹配制表符、换页符、空格等                       相当于 `[\t\n\r\v\f]` |
| \S         | 匹配非制表符、换页符、空格等                   相当于 `[^\t\n\r\v\f]` |
| \b         | 匹配单词边界（边界指的是位置，每个字符之间以及首位）         |
| \B         | 匹配非单词边界                                               |
| **.**      | 除了 \n 和 \r ，其他全能匹配                                 |

\w

> 作用：匹配字母、数字和下划线
>
> 即：`[ A-Z  a-z  0-9  _ ]`
>
> 语法：`/\w/`

```js
let str = '今天星期6，明天是Sunday';
let reg = new RegExp(/\w/, 'g')
console.log(str.match(reg));
//结果：['6', 'S', 'u', 'n', 'd', 'a', 'y']
```

\W

> 作用：匹配字母、数字和下划线
>
> 即：`[ ^A-Z  ^a-z  ^0-9  ^_ ]`
>
> 语法：`/\W/`

```js
let str = '今天星期6&明天是Sunday';
let reg = new RegExp(/\w/, 'g')
console.log(str.match(reg));
//结果：['今', '天', '星', '期', '&', '明', '天', '是']
```

\b

> 作用：匹配单词边界

如：![JS_正则_单词边界](F:\学习\前端培训\笔记\image\JS_正则_单词边界.png)

### 边界符/定位符

| **边界符** | **概述**                     |
| ---------- | ---------------------------- |
| ^          | 表示匹配行首的文本(以谁开头) |
| $          | 表示匹配行尾的文本(以谁结束) |

注：

> 1、如果 ^ 和 $ 组在一起，表示必须精确匹配
>
> 2、**^写在中括号里面，表示取反**

^ 

> 语法：`/^xxx/`
>
> 作用：以xxx开头
>
> 一般用在字符串中；如果用在了 `[^]`，则表示这个字符集的否定（即取括号内的非）

$

> 语法：`/xxx$/`
>
> 作用：以xxx结尾
>

如：

```js
let reg1 = /^132/
//表示：只能以123开头，否则匹配不到

let reg2 = /456$/
//表示：只能以456结尾，否则匹配不到
```

### 运算符

或运算符

> 作用：匹配前面或者后面的字符
>
> 语法：`|`
>
> 如：
>
> ```js
> let str = 'wangze 就是 wangze';
> let reg = /wangze|是/g;
> console.log(str.match(reg));
> //结果：['wangze', '是', 'wangze']
> ```

### 量词符

> `{}`是量词
>
> `[]`是区间
>
> `()`是分组

作用：用于设定某个模式出现的次数

| **量词** | **说明**                     |
| -------- | ---------------------------- |
| *        | 重复 0 次 或者 更多次        |
| +        | 重复 1 次 或者 更多次        |
| ?        | 重复 0 次 或者 一次          |
| {n}      | 重复 n 次                    |
| {n,}     | 重复 n 次 到 无穷（包含n）   |
| {n,m}    | 重复 n 到 m 次  （包含n和m） |

{}

如：

```js
let str = 'this is year2022';
let reg = /year\d{4}/;
console.log(str.match(reg));
//结果：['year2022']
```

特殊情况：`/\d{0,1}/` 	会匹配边界
即：0会匹配到边界

### 区间

Unicode编码：\u4e00-\u9fa5		代表匹配所有的中文

语法：`/[A-z]/`	`/[\u4e00-\u9fa5]/`

如：

```js
let str = 'this is year2022但是今年过的很快';
let reg = /[\u4e00-\u9fa5]+/;
console.log(str.match(reg));
console.log(reg.exec(str));
//结果都是：['但是今年过的很快']

//中括号代表字符集，匹配到中括号内的任意字符即可匹配成功
//相当于	/^a | ^b | ^c/
let reg2 = /^[abc]/;
console.log(reg2.exec('apply'));	//结果：匹配到了a
console.log(reg2.exec('banana'));	//结果：匹配到了b
```

### 贪婪模式

> 定义：尽量往指定范围类最大的匹配（即：往多的找）
>
> 用法：量词 + 或者 * 默认贪婪匹配
>
> > `+ --> {1,}`	 相当于：1次或多次
> >
> > `* --> {0,}`	 相当于：0次或多次
>
> 注：
>
> > 1.  \d 是匹配数字，但是只能一个一个取匹配，就算多个数组紧挨着，也是单个匹配，没法匹配一串数字
> > 2.  就可以实现匹配一串，如 \d+，此时就会匹配一串数字
> > 3.  与 + 类似，不过因为多匹配个0次，所以会匹配到边界

如：

```js
let reg = /^a+/;
console.log(reg.exec('aaaba'));
//结果：['aaa']
```

### 惰性模式

> 定义：尽量往指定范围类最小的匹配（即：往少的找）
>
> 用法：在量词后面加上 `?` 符号，变为惰性匹配
>
> > `+? --> {0,1}`	相当于：1 || 0
> >
> > `*? --> {0,1}`	相当于：1 || 0

如：

```js
let reg = /^aa+?/;
console.log(reg.exec('aaaba'));
//结果：['aa']
```

### 分组

> 定义：正则表达式使用圆括号()进行组匹配
>
> 作用：

#### 分组匹配

如：

```js
let reg1 = /wzwz/g;
let reg2 = /(wz){2}/g;
//此时reg1和reg2是一样的
```

#### 扩展选择

> 作用：可以获取每一组的信息
>
> 语法：`RegExp.$n`
>
> 参数：n：代表第n组

如：

```js
let str1 = '王之阿泽巨帅';
let reg1 = /(王|泽|帅)/g;
console.log(str1.match(reg1));
//结果：[ '王', '泽', '帅' ]

let str2 = '2022-2-31?';
let reg2 = /(\d+)-(\d+)-(\d+)/;
console.log(str2.match(reg2));
//结果：['2022-2-31',  '2022',  '2',  '31',  index: 0,  input: '2022-2-31?',  groups: undefined]

//此时可以拿到每一组的数据
console.log(RegExp.$1);		//结果：'2022'
console.log(RegExp.$2);		//结果：'2'
console.log(RegExp.$3);		//结果：'31'

//替换
str2.replace(reg2, '$1/$2/$3');		//此时$不加RegExp，因为前面已经是一个正则表达式了，后面的$默认为正则表达式的$
console.log(str2);
//结果：'2022-2-31?'
```

#### 具名组匹配

> 定义：给每一个组指定一个名字
>
> 作用：便于阅读
>
> 语法：`(?<name>xxx)`
>
> 参数：
>
> > name：自己取的名字
> >
> > xxx：匹配模式
>
> 使用：`obj.groups.name`
>
> 如：
>
> ```js
> let str = '2022-2-31?';
> let reg = /(?<year>\d+)-(?<month>\d+)-(?<day>\d+)/;
> let obj = str.match(reg);
> //或：let obj = reg.exec(str);
> console.log(obj.groups.year);	//结果：2022
> ```
>
> 



